---
title: 数据在内存中的存储
swiper_index: 2
description: 数据在内存中的存储
abbrlink: 6601b08a
date: 2023-01-20 11:35:46
updated:
type:
comments:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

# 数据在内存中的存储

## 1 内存是什么样子的？内存如何分配？

### 1.1 内存的样子

内存可以想象成一个连续的物理空间。

![](http://roj0q7xhu.hn-bkt.clouddn.com/1674100190519.png)

### 1.2 内存的分配

#### 1.2.1 总述

内存分配分为三种：静态、栈区、堆区。

![](http://roj0q7xhu.hn-bkt.clouddn.com/1674105064983.png)

#### 1.2.2 分别解释

（1）静态存储区：主要存放static静态变量、全局变量、常量。这些数据内存在编译的时候就已经为他们分配好了内存，生命周期是整个程序从运行到结束。

（2）栈区：存放局部变量。在执行函数的时候（包括main这样的函数），函数内的局部变量的存储单元会在栈上创建，函数执行完自动释放，生命周期是从该函数的开始执行到结束。

**栈区的使用习惯：先使用高地址，再使用低地址**。

eg：

```c
int main()
{
    int i = 3;
    int arr[2] = {1,2};
    return 0;
}
//【注】：i和arr数组是局部变量，存放在栈区，而栈区使用习惯是先使用高地址，再使用低地址，而且一般的家庭计算机数据存储方式是小端存储，所以i和arr在内存上应该是这样：
```



![](http://roj0q7xhu.hn-bkt.clouddn.com/1674102624714.png)

（3）堆区：程序员自己申请一块任意大小的内存—也叫动态内存分配。这块内存会一直存在直到程序员释放掉。C语言中，用malloc or new动态地申请内存，用free or delete释放内存。良好习惯：若申请的动

态内存不再使用，要及时释放掉，否则会造成内存泄露。



## 2 C语言中有那些数据类型呢？

### 2.1 整形家族：

（1）char: unsigned char 和 signed char(注：char虽然是字符类型，但是本质上以ASCII码，即数字存储)     占位1字节

（2）short: unsigned short int 和 signed short int                                           占位2字节

（3）int: unsigned int 和 signed int                                                         占位4字节

（4）long: unsigned long int 和 signed long int                                              占位4字节

### 2.2 浮点数家族

（1）float                                                                                   占位4字节

（2）double                                                                                  占位8字节

### 2.3 构造类型（自定义类型）

（1）结构体类型（struct）

（2）数组（分为一维数组，二维数组，指针数组...）

（3）联合体（union）

（4）枚举（enum）

### 2.4 指针类型

（1）一级指针

（2）二级指针

（3）数组指针

（4）函数指针

### 2.5 空类型

## 3 数据在内存中的存储

### 3.1数据的存储，需要考虑两方面，一是整数以补码的形式存储，二是大小端存储

#### 3.1.1 补码的表示

（1）正整数：原码、反码、补码相同

（2）负整数：以signed int a = -10为例

原码:10000000000000000000000000001010

反码:11111111111111111111111111110101

补码:11111111111111111111111111110110

#### 3.1.2 大小端存储

**数据的低位在低地址为小端存储。**

**数据的低位在高地址为大端存储。**

##### 3.1.2.1 那么何为数据的低位和高位呢？

二进制：10111100000（左边高位，右边低位），八进制，十六进制等同上，权值高的是数据的高位。

##### 3.1.2.2 如何判断计算机大小端？

```c
int main()
{
    int a = 1;//补码是00000000000000000000000000000001
    char* b = (char*)&a;
    if (*b == 0)
    {
        printf("大端存储");
    }
    else
    {
        printf("小端存储");
    }
    return 0;
}
```



### 3.2 整形的存储

以补码形式在内存中存储，存储时注意大小端的问题

### 3.3 浮点数的存储

**【注】：浮点数在内存中存储仍有大小端的问题**

#### 3.3.1 浮点数的表示

根据国际标准IEEE（电气电子工程师学会）754，任意一个二进制浮点数V都可以表示为以下形式：

V = （-1）^ S * M * 2 ^ E

S：符号位，只能是0或者1，当S为0时，V是正数。当S为1时，V是负数。

M：有效数，位于1到2区间内

E：指数位

eg：

![](http://roj0q7xhu.hn-bkt.clouddn.com/1674180908202.png)

#### 3.3.2 浮点数的存储

##### 3.3.2.1 float类型

IEEE754规定：对于32位的float类型，最高的一位是符号位S，接着8位是指数E，剩下的23位是有效数M。

![](http://roj0q7xhu.hn-bkt.clouddn.com/1674181529320.png)

##### 3.3.2.2 double类型

IEEE754规定：对于64位的double类型，最高的一位是符号位S，接着11位是指数E，剩下的52位是有效数M。

![](http://roj0q7xhu.hn-bkt.clouddn.com/1674182013294.png)

##### 3.3.2.3 浮点数有高低地址吗？

当然！浮点数在计算机中存储也需要考虑大小端的问题，对于浮点数，右边是低地址，左边是高地址

##### 3.3.2.4 S、M、E怎么存入呢？

（1）S，就直接存在第一位即可，0/1

（2）M，它的范围是（1，2），所以存入为了节省一位有效位，只存储小数点后面的位数，如 M = 1.0101，那么在M中就只存0101，剩余的位数补0

（3）E，IEEE规定指数位E是无符号数，而用 V = （-1）^ S * M * 2 ^ E 来表示时，E是有符号数，可能是负数【eg，0.1 = (-1)^0 * 1.0 * 2^(-1)】，在8位指数位下，E ∈（-127，128），在11位指数位下，E ∈（-1023，1024）

​	（1）float，指数位E是8位，对于无符号数来说，E ∈（0.255），所以要在原本的E的基础上加上127，使它转化成无符号数。

​	（2）double，指数位E是11位，对于无符号数来说，E ∈（0.2047），所以要在原本的E的基础上加上1023，使它转化成无符号数。

##### 3.3.2.5 S、M、E怎么取出呢？

（1）S，就直接取出第一位即可，0/1

（2）M，取出小数点后面的位数后，再加上1.0即可，当E为全0时，加上0.0

（3）E，分为三种情况

​	（1）E不是全0或全1

​		float，直接减127，double，直接减1023

​	（2）E是全0

​		0-127后，得到E是-127，由 V = （-1）^ S * M * 2 ^ E 表达式可知，V非常小，所以IEEE规定，M取出后直接在前面加上0.0

​		0-1023后，同上

​	（3）E是全1

​		float，11111111（十进制255）-127，得到E是128，由 V = （-1）^ S * M * 2 ^ E 表达式可知，V表示无穷大，无意义。

​		double，11111111111（十进制2047）-1023，得到E是1024，由 V = （-1）^ S * M * 2 ^ E 表达式可知，V表示无穷大，无意义。

### 3.4 构造类型（自定义类型）的存储(先以数组为例，其他待续...)

数组在地址中始终是数组的低位元素在低地址，高位元素在高地址。

其中一个元素的存储符合大小端的规则。（见1.2.2图）

### 3.5 指针类型的存储

待续...



































